The difference between the scripting and automating:
scripting                                                         programing
*write to automate the particular task                      *one program can do many tasks
*do not require the compiling,it is interpreter             *must compile to execute

========================================================================================

bash  stands --> born again shell --> bash is advanced version of shell


"#!/bin/bash"  -->#!/bin/bash  is used to define the which shell we are using to execute the commands

In Bash scripting indentation will not matter,better keep indentation like python to understand other well

*cat /etc/shells  --> check how many shells are available in your system

*cat /etc/*release*  --> check os and their version

*creating shell sctipt file with .sh is best practice(without .sh will also work) and after creating change into executable mode
Run --> chmod 755 your_file_name.sh

*for comment in shell script use # this is comment

*for  writing the multiple line statement and consider that as comment using

<<comment
variable scope
if we use local key word while definig variable,that variable is only accessable with that function or block.
declaring the variable without local key word is called global variable,you can use that variable in any where in the script
comment

*for commenting the multiple line commands using below approach

: '
command1
command2
command3
command4
'

The commands will not execute in bash script
command1
command2
command3
command4

==========================================================================================
multi-line commands --> we can write the single long commands as in multiple line using line continuation characters or
                        by enclosing the command in parentheses.
                        i always go with line contunuation method because same method will work for dockerfile

systax:

command arg1 \
        arg2 \
        arg3 

Ex:
  echo "Today is $(date \
  +%A)"
 
  echo "Hi I am Raghu " \
       "I am from Malavalli "\
       "My father name is Nagendra "

=========================================================================================
Access the varibale value and array value in Bash scripting:

#variable
Name="Raghu M N"
age=34

echo "My name is $Name and my age is $age"

#Arrays
1) Indexed array --> Elements inside the array is space seperated 

months=("Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec")

echo "The my birthday date is 13-${months[6]}-1999"
echo "The entire content of array is ${months[@]}"
echo "The number of elements in array is ${#months[@]}"

2)Assosiated array also called as Hash table,dictonary

declare -A my_details

my_details["name"]="Raghu M N"
my_details["age"]=24
my_details["Town"]="Malavalli"
my_details["Degree_colllege"]="MSRIT"


echo "The entire content of array is ${my_details[@]}"
echo "The numbers of elements in array is ${#my_details[@]}"
echo "The key in arrya is ${!my_details[@]}"


=========================================================================================

The usage of >&2 in bash scripting

The >&2 part in "-$OPTARG" >&2 is used to redirect the error output to standard error (file descriptor 2) 
instead of the regular standard output (file descriptor 1). 
It is a way to display error messages on the terminal or log them separately from regular output.

=========================================================================================

*there are two types of variables in any system
       i)system varibales (The variables all letters in capital are system variable generally but user also can define with capital letter)
         use command "env" or "printenv" to check the system varibales
         example --> PATH
       ii)user defined variables in terminal
          export name="Raghu"
          export NAME="Ravi" 
          this is user defined variables

variables must be starts with only letters,variables are case sensitive(name and Name both are different varibles).
defining variable in script:
Name=Raghu
Age=24

=========================================================================================

The special variables in bash
$*  --> it stores the complete set of positional parameters as single string
$#  --> it set to number of arguments specified
$0  --> The filename of the current script
$1  --> stoes the first argument passed after file name
"$@" --> each quoted string treated as a seperate argument
$?  --> exit status of last command
$$  --> process id of current script
$!  --> process id of the last background job

=========================================================================================

*if,elif and else condition operators and format

     if [condition];then
        statement 1
     elif [condition];then
        statement
     else
        statement
     fi
=========================================================================================

Relatinal operators:

  Interger comparition --> i always go with below letters approach for comparition

       * -eq  --> equal to                                if [ $a -eq $b ]
       * -ne  --> not equal                               if [ $a -ne $b ]
       * -gt  --> greater than                            if [ $a -gt $b ]
       * -ge  --> greater than or equal                   if [ $a -ge $b ]
       * -lt  --> less than                               if [ $a -lt $b ]
       * -le  --> less than or equal                      if [ $a -le $b ]
  
  String comparition
       * = or == --> equal to   if [ "$a" == "$b" ] or if [ "$a" = "$b" ] both are same
       * !=      --> not equal  if [ "$a" != "$b" ] 
       * -z --> string is null,has zero length if [ -z "$a" ]

=========================================================================================
Logical operators: To write multiple conditions,validate mutiple conditions and execute the statement

In logical operatos,i always go with letters approach to with one approach

AND  --> -a or &&               OR   --> -o or ||                  NOT  --> -n or ! 

[ 1 -a 1 ] --> 1                  [ 1 -o 1 ] --> 1                -n [ 0 ]  --> 1 
[ 1 -a 0 ] --> 0                  [ 1 -o 0 ] --> 1                -n [ 1 ]  --> 0
[ 0 -a 1 ] --> 0                  [ 0 -o 1 ] --> 1
[ 0 -a 0 ] --> 0                  [ 0 -o 0 ] --> 0      

Example:i am using leters
                   
[ 5 -gt 6 -a  8 -lt 10 ]  --> 0 any one value is false Result is false

[ 3 -lt 5 -o 6 -gt 5 ]   --> 1  any one value is true Result is True

-n [ 5 -gt 4 ]   --> 0 
       

=========================================================================================

if, elif , else conditional statements

syntax:

                if [ condition1 ];then
                ...
                ...
                elif [ condition2 ];then
                ...
                ...
                elif [ condition3 ];then
                ...
                ...
                else
                ...
                ...
                fi

nested if:

if [ condition1 ];then
   if [ condition2 ];then 
   .....
   .....
   elif [ condition3 ];then
   ....
   ....
   else
   ....
   ....
   fi
else
....
....
fi

=========================================================================================

while loop --> check the condition and execute the block of code if the condition is true, 
it continues untill the condition become false

syntax:

while [ condition ]
do
...
...
...
done

=========================================================================================

for loop  --> itirate over the any data type(list,numbers,string) and fetch the values

syntax:

for <variable> in <values to variables>
do
<execution commands>
done

=========================================================================================

case statement --> it is used to do condition branching based on value of variable and execute the that block of case

syntax:

case value in
pattern1)
# commands to execute if value matches to pattern1
;;
pattern2)
# commands to execute if the value matches to pattern2
;;
pattern3)
# commands to execute if the value matches to pattern3
;;
*)
esac

=========================================================================================

continue statement

In bash scripting,continue statement is used to skip the rest of current iteration based on condition 
and move on to next iteration

it is commonly used within the loops like for loop and while loop

=========================================================================================

set command in bash script

In bash scripting,set command is used to set values to postional arguments and change the values of shell options,
also used unseting the value to  variables

shell options:
 
set -e  --> Exit on error mode, Exit immidiately if any command fail , always use "set -e" in script to exit if single command fail
set +e  --> Don't exit even commands fail

set -x --> xtrace option --> enable the debugging mode,print the command with additionally expands variables and arguments before, give more info for de
set +x --> disable the debugging mode

set -v  --> verbose option --> print each command as they written in script,if you want see the exactly  written script
set +v  --> disable command echoing

set -u  --> nounset option  --> strict mode --> treat the refering an undefined variable as error

=========================================================================================

shift command  --> whenever you execute the shift commmand in script, it will shift the right postional argument to left postional argument and left positinal argument will get deleted

Ex:

see the 19.shift_postional_parameters.sh file

=========================================================================================

function  --> In bash scripting,function allow you to group a set of commands and execute them as single unit.
              function accecpt the arguments,perform the task and return the value if needed
              In Bash scripting, the return value is assigned to the $? variable. 

syntax:

function_name(){
   #Function body(commands to execute)
}

function_name   --> calling the function

or

function function_name(){
   #Function body(commands to execute)
}

function_name   --> calling the function

Both the sytax is valid, we can any of it. i always go with the first syntax

=============================================================================================

basename command in bash script is used to retrieve the last file/directory name of given path

syntax:

basename path_to_file or directory

Ex:

basename /home/nraghu/ravi.txt --> the output of this command is ravi.txt 

basename /home/nraghu  --> the output of this command is nraghu  

=============================================================================================

until loop --> The main difference between while loop and until loop is,until loop execute its code when the condtion is false(exit status 1).

syntax:

until [ condition ]
do
#commands to execute until the condition becomes true 
done

=============================================================================================

getopts  

In Bash scripting, getopts is a built-in command that allows you to parse command-line options and arguments easily.
It is particularly useful when you want to create scripts that accept various options and parameters from the user. 
getopts works well for simple option handling, but for more complex cases, 
you might want to consider using external libraries like getopt

syntax:

while getopts OPTIONSTRING VARIABLE
do
  case "$VARIABLE" in
    OPTION1)
      # paased value is $OPTARG
      ;;
    OPTION2)
      # paased value is $OPTARG
      ;;
    \?)
      # paased value is $OPTARG
      ;;
  esac
done

In above syntax OPTIONSTRING is mention option user will pass give the value and VARIABLE is simple one varibale

ex:   OPTIONSTING --->  ":a:b:c"  user need to pass arugument like -a Raghu -b M -c N 
      the value will store in $OPTARG variable

=============================================================================================
